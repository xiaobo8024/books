# Java中二进制的原码反码补码


1. 计算机在任何情况下都只能识别二进制。

2. 计算机在底层存储数据的时候，一律存储的是“二进制的补码形式”。计算机采用补码形式存储数据的原因是：补码形式效率最高。

3. 对于一个正数来说：二进制原码、反码、补码是同一个，完全相同。
    int i = 1;

  ```
  对应的二进制原码：00000000 00000000 00000000 00000001
  对应的二进制反码：00000000 00000000 00000000 00000001
  对应的二进制补码：00000000 00000000 00000000 00000001
  ```

  

4. 对于一个负数来说：二进制原码、反码、补码的关系：
    byte i = -1;

  ```
  对应的二进制原码：10000001（首位是符号位，1表示负号）
  对应的二进制反码：11111110（符号位不变，其它位取反）
  对应的二进制补码：11111111（反码+1）
  ```

  

5. 举例分析 byte b = (byte)150;
int类型的4个字节的150的二进制码是：00000000 00000000 00000000 10010110
将以上的int类型强制类型转为1个字节的byte，最终在计算机中的二进制码是：10010110

注意：计算机永远存储的都是二进制补码形式。

```
即10010110 这个是一个二进制补码形式，可以采用逆推导的方式推算出二进制原码。
10010110 ---> 二进制补码形式
10010101 ---> 二进制反码形式
11101010 ---> 二进制原码形式 
```

11101010 = -106 

```
public class Test{
	public static void main(String[] args){
		byte b = (byte)150;
		System.out.println(b); // -106
	}
}
```



# 为什么补码取反加1？

补码首先要计算反码，也就是取反得到反码。

例如：

在1byte单位中

-5的8位二进制为10000101 #第一位1表示位符号负数，

-5的反码为：11111010

-5的补码为：11111011 #反码加1

5的8位二进制为00000101 #第一个0表示符号位正数+，由于5位正数，其反码与补码均保持不变（原因下面会提到）

为什么补码要取反加1？

这涉及到“模(mod)”的概念。“模(mod)”是指一个计量系统的计数范围，例如：时钟的计量范围是0~11，模=12。同样计算机也可以看成一个计量机器，因为计算机的字长是定长的，即存储和处理的位数是有限的，因此它也有一个计量范围，即都存在一个“模(mod)”。表示n位的[计算机](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338)计量范围是0~2^n-1，模=2^n，“模”实质上是计量器产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示出模的余数。



任何有模的计量器，均可化减法为加法运算。

假设一个时钟当前时针指向8点，而准确时间是6点，调整时间可有以下两种方式：

其一是倒拨2小时，即8-2=6；

其二是顺拨10小时，8+10=12+6=6，即8-2=8+10=8+12-2(mod 12)。



在12为模的计时系统里，加10和减2效果是一样的，因此凡是减2运算，都可以用加10来代替。一般可用公式表示为：a-b=a-b+mod=a+mod-b。对“模”而言，2和10互为补数。实际上，以12为模的系统中11和1、8和4、9和3、7和5、6和6等等都有互为补数的性质，共同的特点是两者相加等于模。

对于计算机的计数原理，其概念和方法完全一样。n位计算机，设n=8，所能表示的最大数是11111111，若再加1成100000000(9位)，但因只有8位，最高位1自然丢失（相当于丢失一个模）。又回到了 00000000，所以8位二进制系统的模为2^8  ——也就是11111111。

同理在计算机系统中处理减法时，也可以按照时钟方式化减法为加法，只需把减数用相应的补数表示就可以了。



以公式a-b=a-b+mod=a+mod-b为例，

```
设: -b=10000101(-5的二进制)，

模(mod)=11111111

a-b=a+(-b的补数)=a+(mod-b)=a+(11111111-10000101)
```

由于二进制的特性，11111111减去10000101得到补数11111010，实际就等于10000101各位取反——也就是反码，如下对应关系：

```
11111111 #模(mod)

10000101 # -5二进制

11111010 #-5二进制补数（即反码）
```

（这里要注意第一位符号位是不变的）

但是在实际计算中补数（反码）还必须加1——即：

```
11111010+1（00000001）=11111011
```

这是因为在8位二进制系统中，模=2^8=256，表示为二进制是100000000，是九位二进制数，在8位二进制系统中实际产生溢出位无法计算，而8位二进制系统计量范围是0~2^n-1，也就是0~257，最大值是257，也就是我们上面计算中模的取值二进制11111111，也就是说为了便于计算，我们是用257的二进制11111111，代替了模256的实际值100000000，那么在实际计算中取得补数后，必须加上这个差值1才不会出错，即：

补数（反码）+1=补码

这就是为什么补码加1的原因。

看到这里也就明白了为什么正数的反码补码不变。