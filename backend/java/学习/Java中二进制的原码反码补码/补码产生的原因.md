# 补码产生的原因

补码“模”概念的引入、[负数](https://baike.baidu.com/item/负数/1294977?fromModule=lemma_inlink)补码的实质、以及补码和真值之间的关系所揭示的补码符号位所具有的数学特征，无不体现了补码在计算机中表示数值型数据的优势，和[原码](https://baike.baidu.com/item/原码/1097586?fromModule=lemma_inlink)、[反码](https://baike.baidu.com/item/反码/769985?fromModule=lemma_inlink)等相比可表现在如下方面 [3] ：

(1)解决了符号的表示的问题 [3] ；

(2)可以将减法运算转化为补码的加法运算来实现，克服了原码加减法运算繁杂的弊端，可有效简化运算器的设计 [3] ；

(3)在[计算机](https://baike.baidu.com/item/计算机/140338?fromModule=lemma_inlink)中，利用电子器件的特点实现补码和真值、原码之间的相互转换，非常容易 [3] ；

(4)补码表示统一了符号位和数值位，使得符号位可以和数值位一起直接参与运算，这也为后面设计[乘法器](https://baike.baidu.com/item/乘法器/4144271?fromModule=lemma_inlink)除法器等运算器件提供了极大的方便。总之，补码概念的引入和当时运算器设计的背景不无关系，从设计者角度，既要考虑表示的数的类型(小数、整数、实数和复数)、数值范围和精确度，又要考虑数据存储和处理所需要的硬件代价。因此，使用补码来表示机器数并得到广泛的应用，也就不难理解了。 

# Java中二进制的原码反码补码


1. 计算机在任何情况下都只能识别二进制。

2. 计算机在底层存储数据的时候，一律存储的是“二进制的补码形式”。计算机采用补码形式存储数据的原因是：补码形式效率最高。

3. 对于一个正数来说：二进制原码、反码、补码是同一个，完全相同。
    int i = 1;

  ```
  对应的二进制原码：00000000 00000000 00000000 00000001
  对应的二进制反码：00000000 00000000 00000000 00000001
  对应的二进制补码：00000000 00000000 00000000 00000001
  ```

  

4. 对于一个负数来说：二进制原码、反码、补码的关系：
    byte i = -1;

  ```
  对应的二进制原码：10000001（首位是符号位，1表示负号）
  对应的二进制反码：11111110（符号位不变，其它位取反）
  对应的二进制补码：11111111（反码+1）
  ```

  

5. 举例分析 byte b = (byte)150;
int类型的4个字节的150的二进制码是：00000000 00000000 00000000 10010110
将以上的int类型强制类型转为1个字节的byte，最终在计算机中的二进制码是：10010110

注意：计算机永远存储的都是二进制补码形式。

```
即10010110 这个是一个二进制补码形式，可以采用逆推导的方式推算出二进制原码。
10010110 ---> 二进制补码形式
10010101 ---> 二进制反码形式
11101010 ---> 二进制原码形式 
```

11101010 = -106 

```
public class Test{
	public static void main(String[] args){
		byte b = (byte)150;
		System.out.println(b); // -106
	}
}
```



# 为什么补码取反加1？



## 反码补码的产生

## 模的概念

“模(mod)”是指一个计量系统的计数范围，例如 0~9 有十位数，模即为10，如果值为11 即超过模的范围，从0开始计算，表示数是1。相同我在 **反码和补码的产生 **，**存储** 中我有明确指出在1byte单位中，这里的byte即是指一个计量系统的计数范围。

## 存储

无符号的二进制只表示非0的数字大小，例如无符号的1btye 可表示的最大数是255，存储的数为0~255

有符号的二进制表示负数、0、正数，例如有符号的1byte 可表示的最大值是128，存储的数是 -128~127

## 计算

在无符号中，最小值是0，最大值是255，最大值255（二进制表示 1111 1111）进1得（1 0000 0000），即0 ，因为 1byte只有8位进1会溢出，取值只截取后八位。

在有符号中，负数值无法表示，已经不能满足于原码的进1，退1计算，即引出了反码和补码，为了统一整数和负数的计算，计算机永远存储的都是二进制补码形式。计算也是用二进制补码的进行计算。



## 思考

 如何设计反码，可以用于整数的负数，整数，0的存储和计算



### 案例

假设模的大小为半个byte位，即四个bit 单位:

#### 无符号二进制

表示正数时 : 

图一

![2](.\images\2.png)



在半个byte单位为模无符号时，最小值是0，最大值是15，最大值15（二进制表示  1111）进1得（1 0000 ），即0 ，因为 半个byte只有4位进1会溢出，取值只截取后八位。



#### 有符号进制

表示负数时：

图二

![3](.\images\3.png)



##### 有符号二进制的负数符号

在日常生活中 负数 有负数符号 - 号，在二进制中最高位为1 表示负数 符号 -

##### 为什么计算机中的计算都是用的反码

负整数的最大值为-1，即负数的临界值

将模一分为2， 

前半部分原码从小到大排序

后半部分原码从大到小排序

看图一,15 进 1为0，15表示 -1 ，

```
二进制中:
表示数:0 1 2 3 4 5 6 7  8  9  10 11 12 13 14 15

负数最大值为-1，如果要计算负数，-1 为负数临界值，进一位为0，即对应十进制的 15 进一位为0，
即

表示数: 0 1 2 3 4 5 6 7 -8 -7 -6 -5 -4 -3 -2 -1

-8 对应 8 原码 1000
-7 对应 9 原码 1001

如果将最高位1看作是 - （负数符号）舍去负数符号就是非负数整数
例如 -7 舍去-(负数符号) 原码 0001 就是正数 1 , 将1取反 得1110，进一位得 1111 即15表示-1
这样就可以用原码区分正负数，用补码进行计算
占用的最高位1 的数位特殊数字，原码和反码0 ，最高位符号位不变。

补码为什么要取反加+1 ?

最高位为1 作为符号位，但是占用的最高位1 也表示一位数
例如 1000   
如果1不表示符号位，为数字 8 ，表示符号位， 为数字0 ，
所以数字8 和数字0 共用原码和反码，如果符号位为1表示数为8，符号位为0表示数为0
所以数字8的反码才是模的临界值，但是8这个数比较特殊，原码和反码采用的是0 补码是进一位，即1000表示，
-1 的反码进一位为 8 的反码，即为模的临界值。所以负数反码+1 =补码

```

