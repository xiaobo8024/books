# 数组中只出现一次的数字

##### 题目描述：

> 给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。
> 进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

##### 示例 1：

> 输入：nums = [1,2,1,3,2,5]
> 输出：[3,5]
> 解释：[5, 3] 也是有效的答案。

##### 示例 2：

> 输入：nums = [-1,0]
> 输出：[-1,0]

##### 示例 3：

> 输入：nums = [0,1]
> 输出：[1,0]

##### 思路：

> 利用异或的原理,AA=0,A0=A.也就是一个数异或它本身等于0,0异或任何数都等于这个数本身.设数组中两个只出现一次的数字为a,b.则数组中所有元素进行异或得到的结果为c,c=a^b;将c转换成2进制,从右往左寻找第一个为1的位数index.因为异或相异为1.所以a,b的index位不同.根据这一点,将数组分隔成只出现一次数字a和只出现一次数字b的两部分.再分别异或.得到的结果也就是a,b本身.

##### 代码实现：

```
class Solution {
    public int[] singleNumber(int[] input) {
 // 结果数组.
        int[] arr = new int[2];
        int result = 0, index = 0;
        // 设只出现过一次的数字为A,B. result=A^B;
        for (int i = 0; i < input.length; i++) {
            result ^= input[i];
        }
        // 从右往左遍历查找A,B第一个不同的二进制位.
        while ((result & 1) == 0) {
            result = result >>> 1;
            index++;
        }
        // 将数组分为包含A与包含B的两部分.
        for (int num : input) {
            if (((num >>> index) & 1) == 0) {
                arr[0] ^= num;
            } else {
                arr[1] ^= num;
            }
        }
        return arr;
    }
}
```